# 📖 팀 노트

# 출력

## sep

```python
print("Hello", "World")
# Hello World

print("Hello", "World", sep = ",")
# Hello,World

print("Hello","World", sep="\n")
# Hello
# World
```

## end

```python
print("Hello", end=" ")
print("World")
# Hello World
```

## f-string

```python
idx = 1
name = "yong"
print(f"{idx} : {name}")
# 1 : yong
```

# 입력

## import sys

`input()`을 아래처럼 정의하면 좋다.

다만 개행문자(`\n`)까지 출력하기 때문에 `rstrip()` 을 붙여주자

```python
import sys
input = sys.stdin.readline
a = input().rstrip()
```

## 여러개 입력하기

입력형식 : 띄어쓰기

```python
a, b, c = input().split()
```

## 정수 여러개 입력하기(map)

`map`을 이용해 입력 값 정수로 변환하기

```python
a, b, c = map(int, input().split())
```

# 수 / 문자

## 진수 표현

```python
a = 10
# 10 (a는 정수)
b = 10.0
# 10.0 (b는 실수)
c = 0o17
# 15 (8진수로 입력, 10진수로 반환)
d = 0x1f
# 31 (16진수로 입력, 10진수로 반환)
```

## 진수변환

```python
# 10진수 -> 16진수
print("%x"%15)
#f
print("%X"%15)
#F

# 10진수 -> 8진수
print("%o"%9)
#11

# 16진수 -> 10진수
x = int("ff", 16)
print(x)
# 255

# 8진수 -> 10진수
x = int("11", 8)
print(x)
# 9
```

## 비트단위연산

### bool

python에서 정수값 0은 `False` 임.

python에서 !은 not으로 한다.

```python
bool(0)# Falsenot bool(0)# True!bool(0)# 잘못된 표현
```

### AND / OR

비트단위 and 연산은 두 비트열이 주어졌을 때,
둘 다 1인 부분의 자리만 1로 만들어주는 것과 같다.

이 연산을 이용하면 어떤 비트열의 특정 부분만 모두 0으로도 만들 수 있는데
192.168.0.31 : 11000000.10101000.00000000.00011111
255.255.255.0 : 11111111.11111111.11111111.00000000

두 개의 ip 주소를 & 연산하면
192.168.0.0 : 110000000.10101000.0000000.00000000 을 계산할 수 있다.

실제로 이 계산은 네트워크에 연결되어 있는 두 개의 컴퓨터가 데이터를 주고받기 위해
같은 네트워크에 있는지 아닌지를 판단하는데 사용된다.

이러한 비트단위 연산은 빠른 계산이 필요한 그래픽처리에서
마스크연산(특정 부분을 가리고 출력하는)을 수행하는 데에도 효과적으로 사용된다.

```python
3 & 5 (0b11 & 0b101 -> 0b1)# 13 | 5 (0b11 & 0b101 -> 0b111)# 7
```

### XOR (배타적 OR)

bool 과 정수에서 사용할 수 있다.

정수일 경우 2진법으로 변환되어 XOR연산을 수행한다.

이러한 비트단위 연산은 빠른 계산이 필요한 그래픽처리에서도 효과적으로 사용된다.

구체적으로 설명하자면,
두 장의 이미지가 겹쳐졌을 때 색이 서로 다른 부분만 처리할 수 있다.
배경이 되는 그림과 배경 위에서 움직이는 그림이 있을 때,
두 그림에서 차이만 골라내 배경 위에서 움직이는 그림의 색으로 바꿔주면
전체 그림을 구성하는 모든 점들의 색을 다시 계산해 입히지 않고
보다 효과적으로 그림을 처리할 수 있게 되는 것이다.
비행기 슈팅게임 등을 상상해보면 된다.

```python
bool(1)^bool(0)# True3^5 (0b11^0b101 -> 0b110)# 0b110(2진수) = 6(10진수)
```

### ~ (비트 NOT 연산자, 보수)

아래는 "2진수"에서의 보수표현

2진수에서는 `~n = -n-1`이 성립한다.

```
(ex. 4bit)+7 0111+6 0110+5 0101+4 0100+3 0011+2 0010+1 0001 0 0000------------ ~(0001) = 1110 ... => ~n = -n-1-1 1111-2 1110-3 1101-4 1100-5 1011-6 1010-7 1001-8 1000
```

### 비트시프트

```python
10>>1# 510<<1# 200o17>>1# 70o17<<1# 300x1f>>1# 150o17<<1# 620o17<<2# 124
```

## 유니코드

```python
# 문자 -> 숫자number = ord("A")print(number)# 65# 숫자 -> 문자s = chr(65)print(s)# A
```

## 반올림(format, round)

```python
print(format(3.141592, ".2f"))# 3.14print(round(3.141592, 2))# 3.14
```

## 문자열 뒤집기

```python
a = "abcdefg"print(a[::-1])# gfedcba
```

## 문자열에 앞에 "0" 채우기 (zfill)

`문자열.zfill(범위)`

```python
print("1".zfill(4))# 0001print("111".zfill(4))# 0111
```

## 문자열에 앞에 특정문자 채우기 (rjust)

`rjust()`는 특정문자를 지정할 수 있다.

```python
print("1".rjust(4, "a"))# aaa1print("111".rjust(6, "2"))# 222111
```

## 특정문자 찾기

### find(찾을문자, 찾기시작할위치)

find는 문자열중에 특정문자를 찾고 위치를 반환해준다, 없을경우 -1을 리턴

```python
>>> s = '가나다라 마바사아 자차카타 파하'>>> s.find('마')5>>> s.find('가')0>>> s.find('가',5)-1
```

### startswith(시작하는문자, 시작지점)

```python
>>> s = '가나다라 마바사아 자차카타 파하'>>> s.startswith('가')True>>> s.startswith('마')False>>> s.startswith('마',s.find('마')) #find는 '마' 의 시작지점을 알려줌 : 5True>>> s.startswith('마',1)False
```

### endswith(끝나는문자, 문자열의시작, 문자열의끝)

```python
>>> s = '가나다라 마바사아 자차카타 파하'>>> s.endswith('마')False>>> s.endswith('하')True>>> s.endswith('마',0,10)False>>> s.endswith('마',0,6)True
```
